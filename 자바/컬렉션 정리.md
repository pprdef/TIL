# collection 컬렉션

메모리 상에서 자료를 구조적으로 처리하는 방법을 자료구조라 일컫음
컬렉션은 자바에서 제공하는 자료구조를 담당하는 프레임워크이다.

#### 프레임워크란?
기본적으로 내포한 의미는 '잘 정의된, 약속된 구조나 골격' -> 자바로는 '잘 정의된 약속된 구조의 클래스들'
여러 프로그래머들에 의해 사용되도록, 잘 정의된 클래스들의 모임이라 할 수 있음. 이렇다면 그저 라이브러리에 지니지 않지만,
컬렉션 프레임워크라 일컫는 이유는 클래스들의 정의에 적용되는 설계원칙, 또는 구조가 존재하기 때문.

추가, 삭제, 정렬 등의 기능처리가 간단하게 해결되어 자료구조적 알고리즘을 구현할 필요가 없다.
Java.util 패키지에 포함되어 있음, 인터페이스를 통해 정형화된 방법으로 다양한 컬렉션 클래스 이용 가능

![image-20200716180846595](C:\Users\park\AppData\Roaming\Typora\typora-user-images\image-20200716180846595.png)

위 그림은 컬렉션 클래스가 구현하고 있는 인터페이스의 상속관계를 보여줌.
K, V, E는 제너릭스 뒷부분에서 다룰 예정이다


## 컬렉션 vs 배열

#### 배열의 문제점

1. 한번 크기를 지정시 변경을 할 수 없다.
   공간의 크기가 부족하면 에러가 발생, 할당시에 넉넉한 크기로 할당을 하게 됨(메모리를 낭비)
   필요에 따라서 늘리고 줄이기가 불가능하다 ->주소값 재할당.
2. 배열에 기록된 데이터에 대해 중간 위치의 추가, 삭제가 불편함.
   추가, 삭제할 데이터부터 마지막 기록된 데이터 하나씩을 밀어내며 추가해야함.
3. 한 타입의 데이터만 저장이 가능하다.

#### 리스트의 장점

1. 저장하는 크기의 제약이 없음

2. 추가, 삭제, 정렬 등의 기능처리가 간단하게 해결됨 
   자료를 구조적으로 처리하는 자료구조가 내장되어있어, 알고리즘 구현이 필요 없음 ex)List.sort();

3. 여러 타입을 저장할 수 있다.

   객체만 저장할 수 있기 때문에, 필요에 따라 기본 자료형을 저장해야 할 시에는, Wrapper 클래스를 사용해야함.

| 인터페이스 | 특징                                                         |
| ---------- | ------------------------------------------------------------ |
| List       | 순서가 있는 데이터의 집합, 데이터의 중복을 허용한다. ex) 대기자 명단 |
|            | 구현 클래스 : ArrayList, LinkedList, Stack, Vector           |
| Set        | 순서를 유지하지 않는 데이터의 집합, 데이터의 중복을 허용하지X ex)양의 정수집합, 소수의 집합 |
|            | 구현 클래스 : HashSet, TreeSet                               |
| Map        | 키와 값의 쌍으로 이루어진 데이터의 집합 순서는 유지되지 않으며, 키는 중복 허용 x 값은 중복허용 O |
|            | ex) 우편번호, 지역번호(전화번호) 구현 클래스: HashMap, TreeMap, Hashtable, Properties |

### List

자료들을 순차적으로 나열한 자료구조, 인덱스로 관리되며, 중복해서 객체 저장이 가능함. 구현 클래스로 ArrayList, Vector, LinkedList가 있다.
![image-20200716184903590](C:\Users\park\AppData\Roaming\Typora\typora-user-images\image-20200716184903590.png)

### ArrayList

List의 후손, 초기 저장 용량은 10으로 자동 설정되며, 따로 지정도 가능하다. 저장 용량을 초과한 객체들이 들어오면 자동적으로 증가하며, 고정도 가능하다. 하지만 동기화를 제공하지 않는다
ArrayList를 생성할 때， 저장할 요소의 개수를 고려해서 실제 저장할 개수보다 약간 여유 있는 크기로 하는 것이 좋다. 생성할 때 지정한 크기보다 더 많은 객체를 저장하면 자동 적으로 크기가 늘어나지만 이 과정에서 처리시간이 많이 소요되기 때문이다. 

#### List<E> list = new ArrayList<E>();

### Vector

List의 후손, 기본적으로 ArrayList와 동등하지만, 동기화를 제공한다는 것이 ArrayList와의 차이점.
그래서 List 객체들 중에서 가장 성능이 좋지 않음.

##### 동기화란?

하나의 객체가 여러 쓰레드를 동시에 접근할 수 있기 때문에, 데이터의 일관성을 유지하기 위해 필요함.

| 공통점                                                       | 차이점                                                       |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| - List인터페이스를 구현한다<br />저장순서가 유지되고 중복을 허용한다.<br />- 데이터의 저장 공간으로 배열을 사용한다 | - Vector는 멀티쓰레드에 대한 동기화가 되어 있으나, <br />ArrayList는 그렇지 않다/ |

### LinkedList

배열의 단점을 보완하기 위해 링크드리스트란 자료구조가 고안되었음. 
List의 후손으로, 인접 참조를 링크해서 체인처럼 관리함. 특정 인덱스에서 객체를 제거,추가하게 되면 
앞/뒤 링크만 변경하면 되기 때문에, 객체 삭제와 삽입이 빈번하게 일어나는 곳에선 ArrayList보다 성능이 좋음

#### 순차적 추가/삭제시

ArrayList가 LinkedList보다 빠름.
순차적 삭제한다는 것은, 마지막 데이터부터 삭제해 나간다는 것을 의미하며, ArrayList는 마지막 데이터 부터 삭제할 경우 요소들의 재배치가 필요하지 않기에 상당히 빠르다.

#### 중간데이터 추가/삭제시

LinkedList가 ArrayList보다 빠르다. 
LinkedList는 각 요소간의 연결만 변경해주면 되기 때문에 처리속도가 상당히 빠르고, ArrayList는 각 요소들을 재배치해 공간 확보나, 빈공간을 채워야 되기에 처리속도가 늦다.
사실 데이터의 개수가 그리 크지않다면 어느 것을 사용해도 큰 차이가 나지는 않음.

| 컬렉션     | 읽기(접근시간) | 추가/삭제 | 비 고                                                  |
| ---------- | -------------- | --------- | ------------------------------------------------------ |
| ArrayList  | 빠르다         | 느리다    | 순차적인 추가삭제는 빠름.<br />비효율 적인 메모리 사용 |
| LinkedList | 느리다         | 빠르다    | 데이터가 많을수록 접근성이 떨어진다.                   |

## Set

저장 순서가 유지되지않음, 중복 객체도 저장하지 못하게 하는 자료구조이다. 수학적으로 비유시 집합에 비유됨.
Null값도 중복을 허용하지 않기 때문에 1개의 Null값만 저장이 된다.
해시코드라는 개념을 사용하여 저장하기에 저장 순서를 알수 없음, 저장되는 데이터의 해시코드는 데이터를 구분하는 값으로 사용되기 때문에 중복이 불가능하다.
장점으로는 해시코드를 사용해 데이터를 처리하므로 컬렉션 중에서도 가장 빠르다

구현 클래스는 HashSet, LinkedSet, TreeSet이 있다.

![image-20200716191737639](C:\Users\park\AppData\Roaming\Typora\typora-user-images\image-20200716191737639.png)

#### HashSet

저장되는 데이터의 순서가 중요하지않고, 데이터가 중복되지 않는 컬렉션이 필요시에 Hashset을 사용한다.
ex)로또

#### LinkedHashSet

저장순서를 유지하는 클래스, 하지만 이는 예외적인 클래스로 보는 것이 옳다.
Set은 수학에서 '집합'을 뜻하는데, 집합에는 순서가 존재하지 않는다.
집합에서 중요한 것은 집합을 구성하는 요소이고, 이 요소는 중복되지 않음.

#### TreeSet클래스

Tree와 Set의 특성을 동시에 가지는 컬렉션이다. 저장되는 데이터의 순서가 보장되지 않고, 중복된 데이터를 저장할 수 없으며, 트리구조로 저장이 된다
![image-20200717083718706](C:\Users\park\AppData\Roaming\Typora\typora-user-images\image-20200717083718706.png)

##### tree란?

데이터를 정렬된 상태로 저장하는 자료 구조이다.

![image-20200717055518269](C:\Users\park\AppData\Roaming\Typora\typora-user-images\image-20200717055518269.png)

### Map

데이터가 키(Key)와 밸류(Value)로 구성되어있고, 키와 값은 객체이다.
Map 데이터마다 가지는 키값은 List의 인덱스 역할과 같다. 즉 데이터에 접근할 때 사용하는 정보이다.
키는 중복값을 허용하지 않지만, 값은 중복값을 허용한다. 
키를 사용하여 데이터를 처리하기 때문에.
키가 중복되는 경우, 기존에 있는 키에 해당하는 값을 덮어쓰게 된다.

![image-20200717060244196](C:\Users\park\AppData\Roaming\Typora\typora-user-images\image-20200717060244196.png)

#### HashMap

해싱이란 검색 방법을 사용하기에, 많은 양의 데이터를 검색할 때 효율적이다
키 객체는 hashCode()와 equals를 재정이해 동일 객체가 될 조건을 정해야 함.
때문에 String타입으로 주로 사용한다.

##### 해싱이란?

메모리에 저장된 데이터를 빨리 찾을 수 있도록 주소에 직접 접근할 수 있는 짧은 길이의 값이나 키로 변환하는것

####  TreeMap

![image-20200717083728159](C:\Users\park\AppData\Roaming\Typora\typora-user-images\image-20200717083728159.png)

이진 검색트리의 형태를 가지며, 키와 값을 쌍으로 이루어진 데이터를 저장함. 검색과 정렬에 적합한 클래스이다.
HashMap이 TreeMap보다 검색기능이 뛰어나다. 다만 범위검색이나 정렬이 필요한 경우에는 TreeMap을 사용

#### HashTable

키 객체 만드는 법은 HashMap과 동일하다. 하지만 HashTable은 스레드
동기화(Synchronization)가 된 상태이기 때문에, 복수의 스레드가 동시에
HashTable에 접근해서 객체를 추가, 삭제 하더라도 스레드에 안전하다.

#### Properties

HaseMap의 구버전인 Hashtable을 상속받아 구현한 것, 키와 값을 (Object, Object)의 형태로 저장하는데 비해 Properties는 (String, String)의 형태로 저장하는 클래스
주로 환경설정과 관련된 속성을 저장하며, 데이터를 파일로부터 읽고 쓰는 편리한 기능 제공.

### TreeSet과 TreeMap 정렬방식

TreeSet의 객체와, TreeMap의 key는 저장과 동시에 자동 오름차순 정렬
· 숫자(Integer, Double)타입일 경우에는 값으로 정렬
· 문자열(String)타입일 경우에는 유니코드로 정렬
· 정렬을 위해 java.lang.Comparable을 구현한 객체를 요구하기 때문에
Integer, Double, String은 모두 Comparable 인터페이스를 구현해야 함
(ClassCastException 발생)

Stack
후입선출 LIFO 늦게 들어온 메모리가 처음으로 나간다.

![image-20200717084115191](C:\Users\park\AppData\Roaming\Typora\typora-user-images\image-20200717084115191.png)

![image-20200717084129025](C:\Users\park\AppData\Roaming\Typora\typora-user-images\image-20200717084129025.png)

#### Queue

![image-20200717084930223](C:\Users\park\AppData\Roaming\Typora\typora-user-images\image-20200717084930223.png)